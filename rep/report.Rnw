\documentclass[12pt]{scrartcl}

\usepackage{fontspec}
\usepackage{amsmath,mathtools,unicode-math,microtype,siunitx}

\defaultfontfeatures{Ligatures=TeX}
%\defaultfontfeatures{Renderer=Basic}%Prevent surrogate weirdness, unprintable with poppler
\setmainfont[Numbers={Lining,Monospaced}]{Cambria} % OldStyle,Proportional
%\newcommand{\setliningnumbers}{\setmainfont[Numbers={Lining,Monospaced}]{Cambria}}
\setsansfont[]{Calibri}
\setmonofont[Scale=MatchLowercase,WordSpace=0.75]{Consolas}
\setmathfont{Cambria Math}

\usepackage{booktabs,subcaption}
\usepackage{hyperref}
\usepackage{xcolor,soul}
\usepackage{graphicx}
\usepackage[noae,nogin]{Sweave}
\renewcommand{\baselinestretch}{1.2}

\usepackage{biblatex}
\bibliography{lit}

\sethlcolor{yellow}
\newcommand{\ismax}[1]{\hl{#1}}
\newcommand{\largefig}[1]{\makebox[\textwidth]{\scalebox{0.7}{#1}}}
\newcommand{\Gr}[1]{\makebox[\hsize][c]{\includegraphics[width=0.9\paperwidth]{#1}}}
\def\obs{\text{obs}}
\def\pred{\text{pred}}
\def\sov{\operatorname{Sov}}
\def\ov{\operatorname{Ov}}
\def\state{\operatorname{st}}
\def\minov{\operatorname{minov}}
\def\maxov{\operatorname{maxov}}
\def\len{\operatorname{len}}
\def\obegin{\operatorname{begin}}
\def\oend{\operatorname{end}}
\def\abs{\operatorname{abs}}
\def\rel{\operatorname{rel}}
\def\score{\operatorname{score}}
\DeclarePairedDelimiterX\gen[2]{\{}{\}}{{#1} \; \delimsize\vert \; {#2}} % {a|b}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\title{Enhancing anchored DIALIGN alignments with secondary structure data}
\author{Pascal Schmitt}

\begin{document}

\maketitle

This report is based on data gathered from processing benchmarks from the BALIBASE suite. Multiple alignments are generated from a list of amino acid sequences by DIALIGN-TX. The suite was processed with default DIALIGN and scored using the provided BALISCORE program, giving the \emph{refernece} dataset.
DIALIGN optionally takes a list of \emph{anchors}, i.e. a fixed score describing the correspondence of continuous regions of two sequences. These have been generated using method outlined in the following section. The run with anchors generated without additional data is called \emph{absolute} as no relative scoring takes place. There are four cases where the 24-letter amino acid input sequence is combined with a 3-letter secondary structure sequence. We compare two relative scores to determine if the secondary structure of two substrings matches, \emph{Sov} and \emph{Q3} (see below). And we compare two methods of guessing the secondary structure from the input sequence, PSIPRED \cite{jones1999}, which uses a neural network on profile data generated by PSI-BLAST runs, and IPSSP \cite{aydin2006}, which uses a hidden Markov model, below referred to as \emph{PSI} and \emph{HMM} respectively.

In order to produce a multiple alignment, the secondary structure prediction must be run on all sequences, after that the anchor generator is called with the secondary structure data and produces an anchor file, which is read by DIALIGN which only reads the original input sequences, ignoring the secondary structure.

\section{The algorithm}

We want to find the optimal sequence of non-overlapping ungapped anchors of up to 40 residues length. For this we use a simple dynamic programming algorithm to calculate $f$ for all $i,j$ to get the maximum sum of scores for the anchors and back-track to output these anchors and their individual scores. We do this for all pairs of given input sequences; DIALIGN will automatically discard conflicting anchors.
\begin{align*}
	f(i,j) = \max
		\left\{
		\begin{aligned}
			& f(i - 1, j) \\
			& f(i, j - 1) \\
			& f(i - n - 1, j - n - 1) +
			  \score\bigl(RS_1^{(i - n, \dotsc, i)}, RS_2^{(j - n, \dotsc, j)}\bigr)
			  \text{ for }
			  n = 0,\dotsc,39
		\end{aligned}
		\right.
\end{align*}

\section{Scoring function}

Scoring consists of two parts:
$\score(RS_1, RS_2) = \abs(R_1,R_2) \cdot \rel(S_1,S_2)$.
The absolute score $\abs(R_1,R_2) \in \mathbb R^+$ is calculated as in DIALIGN by simply summing up each residue pair's BLOSUM value and looking up the corresponding weight in DIALIGN's table.
\begin{align*}
	\abs(R_1, R_2) = \operatorname{weight}\left(
		\sum_{i=0}^{n - 1} \operatorname{blosum}\bigl( R_1^{(i)}, R_2^{(i)} \bigr)
	\right)
\end{align*}
It is then multiplied by the relative score $\rel(S_1,S_2) \in [0,1]$ based on the secondary structure. The common $Q_3$ score can be used here:
\begin{align*}
	\rel(S_1, S_2) = Q_3 = \frac{1}{n} \sum_{i=0}^{n - 1}
		\begin{cases}
			1 & \text{if } S_1^{(i)} = S_2^{(i)} \\
			0 & \text{otherwise}
		\end{cases}
\end{align*}
Since we are only interested in the highest-scoring candidate, we can avoid calculating the relative score for every single one: if the absolute score $\abs$ is lower than the running maximum score $M$, the candidate can be disqualified since $\abs < M \Rightarrow \abs \cdot \rel < M$ because $\rel \le 1$. Thus the relative score only needs to be computed for a small fraction of candidates, this allows using a computationally expensive relative score, like $\sov$:

\subsection{Segment Overlap}

The Segment Overlap ($\sov$) score has been developed to evaluate secondary-structure prediction methods, the original definition \cite{rost1994} and the redefinition which generates normed values $\in [0,1]$ \cite{zemla1999} compare an observed structure $S_\obs$ to a predicted structure $S_\pred$ and are not symmetric, generally $\sov(S_\obs, S_\pred) \not= \sov(S_\pred, S_\obs)$.

Here we use $\sov$ not to evaluate the quality of the prediction but to score the match between two predicted secondary structures. For that purpose we define a symmetric version with the property $\sov'(S_1, S_2) = \sov'(S_2, S_1) \approx \bigl( \sov(S_1, S_2) + \sov(S_2, S_1) \bigr) / 2$.

As before, the structures $S_1,S_2$ are divided into segments $s_1 \in S_1$ of a conformational state $\state(s_1) = s_1^{(0)} = s_1^{(1)} = \dotsc \in \{H, E, C\}$, i.e. segments where the secondary structure is predicted to be helix ($H$), strand ($E$) or coil/other ($C$).

$\ov_i$ and $\overline\ov_i$ are the sets of overlapping pairs and non-overlapped segments respectively. To get the symmetric version, the \textcolor{red}{red} parts have been added.

\begin{align*}
	\sov' &= \frac{1}{N}
		\sum_{i \in \{H,E,C\}}
		\sum_{(s_1, s_2) \in \ov_i}
		\frac{\minov(s_1, s_2) + \delta(s_1, s_2)}{\maxov(s_1, s_2)}
		\cdot
		\bigl( \len(s_1) \textcolor{red}{{}+ \len(s_2)} \bigr)
	\\
	\ov_i &= \gen[\big]{ (s_1, s_2) }{
		s_1 \in S_1 \wedge
		s_2 \in S_2 \wedge
		\state(s_1) = \state(s_2) = i \wedge
		s_1 \cap s_2 \not= \emptyset }
	\\
	\overline\ov_i &= \gen[\big]{ s_1 }{
		s_1 \in S_1 \wedge
		\state(s_1) = i \wedge
		\forall s_2 \in S_2 :
			\state(s_2) = i \Rightarrow s_1 \cap s_2 = \emptyset }
	\\
	N &= 
		\sum_{i \in \{H,E,C\}}
		\left(
			\sum_{(s_1, s_2) \in \ov_i}
			\bigl( \len(s_1) \textcolor{red}{{}+ \len(s_2)} \bigr)
			+
			\sum_{s \in \overline\ov_i}
			\len(s)
		\right)
	\\
	\delta(s_1, s_2) &=
		\begin{aligned}[t]
			\min \bigl\{
				& \maxov(s_1, s_2) - \minov(s_1, s_2), \\
				& \minov(s_1, s_2), \;
				\floor{ \len(s_1) / 2 }, \;
				\floor{ \len(s_2) / 2 }
			\bigr\}
		\end{aligned}
	\\
	\minov(s_1, s_2) &= \min\bigl\{ \oend(s_1), \oend(s_2) \bigr\} - \max\bigl\{ \obegin(s_1), \obegin(s_2) \bigr\}
	\\
	\maxov(s_1, s_2) &= \max\bigl\{ \oend(s_1), \oend(s_2) \bigr\} - \min\bigl\{ \obegin(s_1), \obegin(s_2) \bigr\}
	\\
	\len(s) &= \oend(s) - \obegin(s)
\end{align*}


\section{Results}

<<load,echo=FALSE>>=
runs <- c("ref","abs","q3","sov","q3-ipssp","sov-ipssp")
runs.labels <- c("Ref.", "Abs.", "Q3/PSI", "Sov/PSI", "Q3/HMM", "Sov/HMM")

# read file, has seq/run/block(core,all)/sp*tc columns
data <- read.table(file='../run-baliscore-all.dat', header=T, sep='\t')
# convert to seq/run/block/kind(sp,tc)/value
data <- rbind(transform(data, value=sp, kind="sp", sp=NULL, tc=NULL),
              transform(data, value=tc, kind="tc", sp=NULL, tc=NULL))
# useful additions
data <- within(data, {
  run <- factor(run, levels=runs, ordered=T, labels = runs.labels)
  set <- factor(gsub("^BBS?(..).*$", "RV\\1", seq))
  kind.block <- factor(mapply(function(k,b) sprintf("%s (%s)", toupper(k), b), kind, block))
})

# join each non-ref run with ref run
data.ref <- transform(subset(data, unclass(run) == 1), run=NULL)
data.bench <- subset(data, unclass(run) != 1)
data.bench <- merge(data.ref, data.bench,
                    suffixes=c(".ref", ".bench"),
                    by=c("seq","block","kind","set","kind.block"))
@

As can be seen in table~\ref{meanscore}, the mean BALIBASE scores for each method are very close, with unanchored DIALIGN often winning over the anchored methods.

\begin{table}\footnotesize\centering
<<meanscore,echo=FALSE,results=tex>>=
library("tables")
save <- booktabs()
stderr <- function(x) sd(x) / sqrt(length(x))
highlight <- function(x, ...) {
  x <- matrix(x, ...)
  boldmatrix <- matrix(F, ncol=ncol(x), nrow=nrow(x))
  for(i in 1:nrow(x)) {
    boldmatrix[i, which.max(x[i,])] = T
  }
  x <- sprintf("%.2f", x)
  x[boldmatrix] <- sprintf("\\ismax{%s}", x[boldmatrix])
  x
}
vtab <- tabular( Heading("Set")*(1 + Heading() * set) * (Heading("Score") * kind.block)
                 ~ Heading() * (Heading()*run)
                 * (Format(highlight(ncol=6*2)) * (Heading()*value)
                    * (Heading() * Justify("r@{}") * mean
                       + Heading() * Justify("@{\\,$\\pm$\\,}l") * stderr)),
                 data=data)
latex(vtab)
@
\caption{Mean values and standard error for each run and score, best value before rounding marked like \ismax{this}.}\label{meanscore}
\end{table}

% Plots
<<init,echo=FALSE>>=
library(lattice)
library(RColorBrewer)

# names(trellis.par.get())
theme <- standard.theme(color=F)
theme$box.dot <- theme$box.rectangle <- theme$box.umbrella <- list(lty=1, col="black") #list(alpha=1, col="black", lty=1, lwd=0.8)
theme$superpose.symbol$pch <- 1:7
theme$background$col <- "transparent"
theme$background$alpha <- 0
lattice.options(default.theme = theme)
@

The box plots in figure~\ref{bplot} illustrate the problem more clearly, as the overlapping notches show, there's no significant difference, although the anchored methods produce more outliers.

\begin{figure}
\largefig{%
<<bplot,fig=TRUE,echo=FALSE,width=10,height=12>>=
bwplot(run ~ value | kind.block * set, data,
       notch=T, pch="|",
       par.settings=list(box.rectangle=list(fill=brewer.pal(6, 'Paired'))),
       layout=c(4,6)
       )
@
}
\caption{Boxplots for each methods's score for each benchmark set}\label{bplot}
\end{figure}

In figure~\ref{xyplot} the scatter plots show one dot per multiple alignment, the unanchored reference score on the horizontal axis and the anchored score for each method on the vertical axis. Overall there is a good correlation to the reference, with about the same number of multiple alignments getting higher or lower scores. To investigate this further we compare a linear model $g$ of this with the identity function $f$: we can see that $g$ is sloped slightly more horizontally, meaning that low scores are raised and high scores lowered using anchors.

\begin{figure}
\largefig{%
<<xyplot,fig=TRUE,echo=FALSE,width=10,height=10>>=
xyplot(value.bench ~ value.ref | run * kind.block, data.bench,
       aspect="iso",
       xlab="Unanchored score",
       ylab="Anchored score",
       panel=function(x,y,...){
         panel.xyplot(x,y,...,pch="*")
         panel.abline(0,1,col="blue")
         panel.lmline(x,y,col="red")
       }
       )
@
}
\caption{The score for each alignment with anchors plotted over its unaligned score. The \textcolor{blue}{blue} line shows $f(x)=x$, the \textcolor{red}{red} line is a linear model $g(x)=\alpha x+\beta$. The anchored method is better where $g(x) > f(x)$.}\label{xyplot}
\end{figure}

The differences are too insignificant to judge as a whole, but analyzing the greatest winners and loosers as shown in table~\ref{delta} might help determine why secondary structure information helped in some cases but failed in others.

\begin{table}\centering
<<echo=FALSE,>>=
library("xtable")
data.del <- transform(data.bench, delta = value.bench - value.ref)
seq.del <- transform(aggregate(delta ~ seq, data.del, mean), mean=delta, delta=NULL)
seq.del$stderr <- aggregate(delta ~ seq, data.del, stderr)$delta
mktable <- function(x) {
  print(xtable(x, align=c("", "r", "r@{\\,$\\pm$\\,}", "@{}l")),
        include.rownames=F,
        include.colnames=F,
        only.contents=F,
        booktabs=T,
        floating=F,
        add.to.row=list(pos=list(0), command=c("Name & \\multicolumn{2}{c}{$\\Delta$ score}\\\\")))  
}
@
\begin{minipage}[t]{.3\hsize}
<<echo=FALSE,results=tex>>=
mktable(head(seq.del[order(-seq.del$mean),]))
@
\subcaption{Best cases}
\end{minipage}
\hfil
\begin{minipage}[t]{.3\hsize}
<<echo=FALSE,results=tex>>=
mktable(head(seq.del[order(seq.del$mean),]))
@
\subcaption{Worst cases}
\end{minipage}
\caption{Mean scores for each multiple alignment over all anchored runs compared to unanchored run.}\label{delta}
\end{table}




\nocite{*}
\printbibliography

\end{document}
